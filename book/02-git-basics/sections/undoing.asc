[[_undoing]]
=== Değişiklikleri Geri Alma (undo)

Herhangi bir aşamada bir şeyi geri almak isteyebilirsiniz.
Burada, yaptığınız değişiklikleri geri almak için kullanabileceğiniz birkaç temel aracı inceleyeceğiz.
Dikkatli olun çünkü bu geri alma işlemlerinin bazılarını her zaman iptal ederek geri alma öncesi duruma geri dönemeyebilirsiniz.
Bu, Git'te yanlış yaparsanız bazı çalışmalarınızı kaybedebileceğiniz birkaç alandan biridir.

Yaygın geri alma ihtiyaçlarından biri, bazı dosyaları eklemeyi unuttup "commit"inizi çok erken yaptığınızda veya yanlış bir "commit" mesajı yazdığınızda ortaya çıkar.
Bir "commit"i yeniden yapmak istiyorsanız, unuttuğunuz ek değişiklikleri yapın, bunları "stage"e alın ve `--amend` seçeneğini kullanarak yeniden "commit" yapın:

[source,console]
----
$ git commit --amend
----

Bu komut "stage" alanınızı alır ve "commit"iniz için kullanır.
Son "commit"inizden beri hiçbir değişiklik yapmadıysanız (örneğin, bu komutu en son "commit"inizden hemen sonra çalıştırdıysanız), anlık görüntünüz tamamen aynı olacak ve değiştireceğiniz tek şey "commit" mesajınız olacaktır.

Bunu yaptığınızda aynı "commit mesajı düzenleyicisi" aynı "commit" mesajıyla devreye girer.
Mesajı her zamanki gibi düzenleyebilirsiniz ancak bu, önceki "commit" mesajınızın üzerine yazılır.

Örnek olarak, "commit" yapar ve daha sonra bu işleme eklemek istediğiniz dosyadaki değişiklikleri "stage"e almayı unuttuğunuzu fark ederseniz, şunun gibi bir şey yapabilirsiniz:

[source,console]
----
$ git commit -m 'initial commit'
$ git add forgotten_file
$ git commit --amend
----

Bu işlemin sonucunda, ikinci "commit"in ilk "commit"in yerini aldığı tek bir "commit" elde edersiniz.

[NOT]
====
Şunu anlamanız özellikle önemli: Eğer son "commit"inizi "amend" ederseniz, son "commit"inizi düzeltmekten ziyade, eski "commit" ortadan kaldırıp ve yerine yeni bir "commit" koymaktasınız.
Sanki önceki "commit" hiç gerçekleşmemiş ve repo geçmişinizde görünmeyecekmiş gibi.

Önceki "commit"leri değiştirmenin asıl değeri, repo geçmişinizi ``Hata, bir dosya eklemeyi unuttum`` veya ``Lanet olsun, son işlemedeki bir yazım hatasını düzelttim`` şeklinde gereksiz "commit" mesajlarıyla doldurmadan, son işleminizde küçük iyileştirmeler yapmaktır.

====

[[_unstaging]]
==== "stage"e Alınmış Dosyayı "stage"den Çıkarmak (Unstaging)

Sonraki iki bölümde "stage" alanınız ve çalışma dizini değişiklikleriyle nasıl çalışılacağı gösterilmektedir.
İşin güzel yanı, bu iki alanın durumunu tanımlamak için kullandığımız komut aynı zamanda bu alanlarda yapılan değişiklikleri nasıl geri alacağımızı da bize söyler.
Örneğin, iki dosyayı değiştirdiğinizi ve bunları iki ayrı değişiklik olarak işlemek istediğinizi, ama yanlışlıkla `git add *` yazıp ikisini birden "stage"e aldığınızı varsayalım.
İkisinden birini nasıl "stage"den çıkarabilirsiniz?
`git status` komutu size bunu nasıl yapacağınızı zaten hatırlatır:

[source,console]
----
$ git add *
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    renamed:    README.md -> README
    modified:   CONTRIBUTING.md
----

``Changes to be committed`` metninin hemen altında, düzenlemeyi kaldırmak için `git reset HEAD <file>...` kullanın yazıyor.
O halde, `CONTRIBUTING.md` dosyasını "stage"den çıkarmak için bu tavsiyeyi kullanalım:

[source,console]
----
$ git reset HEAD CONTRIBUTING.md
Unstaged changes after reset:
M	CONTRIBUTING.md
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    renamed:    README.md -> README

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md
----

Komut biraz garip ama neticede işe yarıyor.
`CONTRIBUTING.md` dosyası değiştirildi ancak nihai durumda "stage"de değil.

[NOT]
=====
`git reset`in tehlikeli bir komut olabileceği doğrudur, özellikle de `--hard` bayrağını kullanırsanız.
Ancak yukarıda açıklanan senaryoda çalışma dizininizdeki dosyaya dokunulmaz, dolayısıyla nispeten güvenlidir.
=====

Şimdilik bu sihirli çağrı, `git reset` komutu hakkında bilmeniz gereken tek şey.
<<ch07-git-tools#_git_reset>> ünitesinde `reset`in ne yaptığı ve çok daha ilginç şeyler yapmak için bunda nasıl ustalaşılacağı hakkında çok daha fazla ayrıntıya gireceğiz.

==== Değiştirilmiş Dosyadaki Değişikliği Geri Alma (Unmodifying)

`CONTRIBUTING.md` dosyasındaki değişikliklerinizi saklamak istemediğinizi fark ederseniz ne yaparsınız?
Yaptığınız değişiklikleri kolayca nasıl kaldırabilirsiniz veya en son "commit"inizdeki (veya başlangıçta klonladığınız ya da çalışma dizininize soktuğunuz) haline nasıl geri döndürebilirsiniz?
Neyse ki, `git status` size bunu nasıl yapacağınızı da söyler.
Son örnek çıktıda, "unstaged" alan şuna benzer:

[source,console]
----
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md
----

Yaptığınız değişiklikleri nasıl iptal edeceğinizi oldukça açık bir şekilde anlatmaktadır.
Hadi söyleneni yapalım:

[source,console]
----
$ git checkout -- CONTRIBUTING.md
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    renamed:    README.md -> README

----

Değişikliklerin geri alındığını görebilirsiniz.

[ÖNEMLİ]
=====
`git checkout -- <file>` komutunun tehlikeli bir komut olduğunu anlamanız çok önemli.
Bu dosyada yaptığınız tüm yerel değişiklikler kayboldu! Git, bu dosyayı en son kaydedilen sürümle değiştirdi.
Kaydedilmemiş yerel değişiklikleri istemediğinizden kesinlikle emin olmadığınız sürece bu komutu asla kullanmayın!
=====

Bu dosyada yaptığınız değişiklikleri korumak istiyorsanız ancak şimdilik yine de ondan kurtulmanız gerekiyorsa, <<ch03-git-branching#ch03-git-branching>> ünitesinde saklama ve dallandırma işlemlerini ele alacağız. Onların genellikle daha kullanışlı yollar olduğunu göreceksiniz.

Git'te _committed_ olan her şeyin neredeyse her zaman kurtarılabileceğini unutmayın.
Hatta silinen dallardaki "commit"ler veya `--amend` komutuyla üzerini yeniden yazılan "commit"ler bile kurtarılabilir. (veri kurtarma için bkz. <ch10-git-internals#_data_recovery>>).
Ancak, hiç "commit" etmediğiniz bir şeyi tamamen kaybetmeniz oldukça muhtemeldir.
